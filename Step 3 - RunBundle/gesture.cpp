#include "myolinux/myoclient.h"
#include "myolinux/serial.h"


#include <iostream>
#include <deque>
#include <array>
#include <string>
#include <fstream>
#include <cmath>
#include <mutex>
#include <vector>
#include <cstdint>
#include <cstring>
#include <chrono>

using namespace myolinux;


/// Type describing a symbol table entry of a generated bundle.
struct SymbolTableEntry {
  // Name of a variable.
  const char *name;
  // Offset of the variable inside the memory area.
  uint64_t offset;
  // The number of elements inside this variable.
  uint64_t size;
  // The kind of the variable. 1 if it is a mutable variable, 0 otherwise.
  char kind;
};

/// Type describing the config of a generated bundle.
struct BundleConfig {
  // Size of the constant weight variables memory area.
  uint64_t constantWeightVarsMemSize;
  // Size of the mutable weight variables memory area.
  uint64_t mutableWeightVarsMemSize;
  // Size of the activations memory area.
  uint64_t activationsMemSize;
  // Alignment to be used for weights and activations.
  uint64_t alignment;
  // Number of symbols in the symbol table.
  uint64_t numSymbols;
  // Symbol table.
  const SymbolTableEntry *symbolTable;
};

// These two external symbols are auto-generated by means of the -bundle option.
extern "C" void network(uint8_t *constantWeightVars,
                         uint8_t *mutableWeightVars, uint8_t *activations);
extern "C" BundleConfig network_config;

void * alignedAlloc(size_t size) {
  void* ans;
  if (posix_memalign(&ans, network_config.alignment, size) != 0) exit(1);
  if ((size_t)ans % 64 != 0) exit(1);
  memset(ans, 0, size);
  return ans;
}

void getFeatures(std::array<float, 64>& features, std::vector<float>& signal, int channelNumber) {
    std::vector<float> diff;
    float iEMG = fabs(signal[0]), sum = signal[0], squareSum = signal[0] * signal[0];
    int ZCR = 0;
    for (int i = 1; i < signal.size(); ++i) {
        iEMG += fabs(signal[i]);
        ZCR += (signal[i] < 0 && signal[i - 1] > 0) || (signal[i] > 0 && signal[i - 1] < 0);
        sum += signal[i];
        squareSum += signal[i] * signal[i];
        diff.push_back(signal[i] - signal[i - 1]);
    }
    float mean = sum / signal.size();
    float stdev = squareSum / signal.size() - (mean * mean);
    float SKE = 0.0f;
    for (int i = 0; i < signal.size(); ++i) {
        float d = signal[i] - mean;
        SKE += d * d * d;
    }
    float sqrtDev = sqrt(stdev);
    SKE /= sqrtDev * sqrtDev * sqrtDev * signal.size();
    int SSC = 0;
    float WL = fabs(diff[0]);
    for (int i = 1; i < diff.size(); ++i) {
        WL += fabs(diff[i]);
        SSC += (diff[i] < 0 && diff[i - 1] > 0) || (diff[i] > 0 && diff[i - 1] < 0);
    }

    int offset = channelNumber << 3;
    features[offset + 0] = iEMG / signal.size();
    features[offset + 1] = SSC;
    features[offset + 2] = ZCR;
    features[offset + 3] = WL;
    features[offset + 4] = SKE;
    features[offset + 5] = sqrt(squareSum / signal.size());
    features[offset + 6] = stdev;
    features[offset + 7] = iEMG;
}

uint8_t * initConstantWeights() {
    FILE * constantWeightsFile = fopen("network.weights", "rb");

    fseek(constantWeightsFile, 0, SEEK_END);
    size_t constantWeightsFileSize = ftell(constantWeightsFile);
    rewind(constantWeightsFile);

    uint8_t * constantWeights = (uint8_t * )alignedAlloc(constantWeightsFileSize);

    if (constantWeightsFileSize != network_config.constantWeightVarsMemSize) exit(1);

    if (fread(constantWeights, constantWeightsFileSize, 1, constantWeightsFile) != 1) exit(1);

    fclose(constantWeightsFile);
    return constantWeights;
}

uint8_t * initActivations() {
  return (uint8_t * )alignedAlloc(network_config.activationsMemSize);
}

uint8_t * initMutableWeights() {
  return (uint8_t * )alignedAlloc(network_config.mutableWeightVarsMemSize);
}

SymbolTableEntry getInputLayer() {
    for (int i = 0, e = network_config.numSymbols; i < e; ++i)
        if (strncmp(network_config.symbolTable[i].name, "input_1_01", 10) == 0) return network_config.symbolTable[i];

    exit(1);
}

SymbolTableEntry getOutputLayer() {
    for (int i = 0, e = network_config.numSymbols; i < e; ++i)
        if (strncmp(network_config.symbolTable[i].name, "save_output_1_Softmax_0", 23) == 0) return network_config.symbolTable[i];

    exit(1);
}

/// input - input_1_01
/// output - output_1_Softmax_0

int main() {
    uint8_t * constantWeights = initConstantWeights()
          , * activations     = initActivations()
          , * mutableWeights  = initMutableWeights();

    SymbolTableEntry  inputLayer  = getInputLayer()
                   ,  outputLayer = getOutputLayer();


    /// CONNECT TO MYO
    myo::Client client(Serial{"/dev/ttyACM0", 115200});
    client.connect();
    if (!client.connected()) {
        return 1;
    }

    /// SET MYO TO SEND EMG DATA
    client.setSleepMode(myo::SleepMode::NeverSleep);
    client.setMode(myo::EmgMode::SendEmg, myo::ImuMode::None, myo::ClassifierMode::Disabled);

    /// DEQUE TO KEEP DATA
    std::array<std::deque<float>, 8> d;

    std::mutex lock;

    int cnt = 1;
    int dataPerSecond = 200, fps = 5;
    int dataUntilPredict = dataPerSecond / fps;
    int dataUntilIntermediatPredict = dataUntilPredict / 5;

    int type = 0; // 0 - 1 prediction; 1 - 5 predictions + sum of argmax over each prediction; 2 - 5 predictions + argmax over sum of predictions


    if (type == 0) {
        dataUntilIntermediatPredict = dataUntilPredict;
    }
    std::array<float, 7> results;

    /// FUNCTION WHEN EMG IS RECIEVED
    client.onEmg([&](myo::EmgSample sample) {
        /// NORMALIZE THE INPUT
        std::array<float, 8> a;
        for (int i = 0; i < 8; ++i) {
            a[i] = (int)sample[i] / 128.0f;
        }
        lock.lock();
        for (int i = 0; i < 8; ++i) {
            d[i].push_back(a[i]);
        }

        // std::cout << d[0].size() << std::endl;
        if (d[0].size() == 50) {
            if (cnt % dataUntilIntermediatPredict == 0) {
                std::array<std::vector<float>, 8> v;
                for (int i = 0; i < 8; ++i) {
                    v[i] = {d[i].begin(), d[i].end()};
                    d[i].pop_front();
                }
                lock.unlock();

                std::array<float, 64> features;
                for (int i = 0; i < 8; ++i) getFeatures(features, v[i], i);

                memcpy(mutableWeights + inputLayer.offset, &features[0], 64 * sizeof(float));

                network(constantWeights, mutableWeights, activations);

                float * partialResults = (float * )(mutableWeights + outputLayer.offset);

                if (type == 0 || type == 1) {
                    int ans = -1;

                    for (int i = 0; i < outputLayer.size; ++i)
                        if (ans == -1 || partialResults[i] > partialResults[ans]) ans = i;

                    results[ans] += 1.0f;
                } else {
                    //for (int i = 0; i < outputLayer.size; ++i)
                    //    std::cout << partialResults[i] << " ";
                   // std::cout << std::endl;
                    for (int i = 0; i < outputLayer.size; ++i)
                        results[i] += partialResults[i];
                 //   for (int i = 0; i < outputLayer.size; ++i)
                   //     std::cout << results[i] << " ";
                   // std::cout << std::endl;
                }
            } else {
                for (int i = 0; i < 8; ++i) {
                    d[i].pop_front();
                }
                lock.unlock();
            }

            if (cnt == dataUntilPredict) {
                int ans = -1;
                for (int i = 0; i < outputLayer.size; ++i) {
                    if (ans == -1 || results[i] > results[ans]) ans = i;
                }

                for (int i = 0; i < outputLayer.size; ++i) {
                    results[i] = 0.0;
                }

                cnt = 0;
                std::cout << ans << std::endl;
            }
            ++cnt;
        } else {
            lock.unlock();
        }
    });

    /// KEEP THE PROGRAM ALIVE
    while (true) {
        client.listen();
    }
    


    return 0;
}
